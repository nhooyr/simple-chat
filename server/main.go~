package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"net"
)

func main() {
	log.SetPrefix("chat server: ")
	addr := flag.String("addr", ":4000", "listen address")
	flag.Parse()
	log.Fatal(ListenAndServe(*addr))
}

type chatRoom struct {
	topic    string
	userList map[string]net.Conn
}

var ChatRoom chatRoom

func ListenAndServe(addr string) error {
	ln, err := net.Listen("tcp", addr)
	if (err != nil){
		return err
	}
	log.Println("Listening on", addr)
	ChatRoom = chatRoom{topic: "Default", userList: make(map[string]net.Conn)}
	for {
		conn, _ := ln.Accept()
		log.Println("New connection from", conn.RemoteAddr().String())
		go newConnection(conn)
	}
}

func newConnection(conn net.Conn) {
	fmt.Fprintf(conn, "Welcome to the Chat Server\n")
	var (
		err error
		username string
	)
	for {
		fmt.Fprint(conn, "What username: ")
		connReader := bufio.NewReader(conn)
		username, err = connReader.ReadString('\n')
		if err != nil {
			return
		}
		username = username[:len(username)-1]
		if _, used := (ChatRoom.userList[username]); used {
			fmt.Fprint(conn, "Username taken\n")
			continue
		}
		if username == "" {
			fmt.Fprint(conn, "Bad name\n")
			continue
		}
		break
	}
	ChatRoom.userList[username] = conn
	outputAll("+++ " + username + " has joined the chatroom.\n", nil)
	go listen(username, conn)
}

func listen(username string, conn net.Conn) {
	connReader := bufio.NewReader(conn)
	for {
		message, err := connReader.ReadString('\n')
		if err != nil {
			conn.Close()
			delete(ChatRoom.userList, username)
			outputAll("--- " + username + " has left the room\n", nil)
			return
		}
		outputAll(">>> " + username + ": " + message, conn)
	}
}

func outputAll(message string, origin net.Conn) {
	log.Println("Broadcast:", message[:len(message)-1])
	for _, conn := range ChatRoom.userList {
		if (conn == origin){
			fmt.Fprint(conn, "<<< "+ message[4:] )
			continue
		}
		fmt.Fprint(conn, message)
	}
}